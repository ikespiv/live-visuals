<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Live Visuals Prototype (p5.js)</title>
<style>
  body {
    margin: 0;
    background: black;
    overflow: hidden;
  }
  canvas {
    position: absolute;
    top: 0;
    left: 0;
  }
</style>
<!-- Load the p5.js library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
</head>
<body>

<script>
let scenes = [];
let currentScene = 0;
let nextSwitchTime = 0;

let video = null;
let t = 0;
let zoomBuffer;
let clipBuffer;
let clip;
let flicker = 175; 
function setup() {
  createCanvas(windowWidth, windowHeight);  // p5 makes the canvas automatically  
  noLoop();
  let startButton = createButton('Start Camera');
  startButton.position(width / 2 - 50, height / 2);

  startButton.mousePressed(() =>{
  video = createCapture(VIDEO);             // open webcam
  video.elt.setAttribute('playsinline','');
  video.size(width, height);                // match video to canvas
  video.hide();                             // hide raw video element

    clip = createVideo('clip.mp4', () => {
  console.log("Clip loaded")
  });
  clip.elt.setAttribute('playsinline', '');
//clip.elt.setAttribute('muted', '');
  clip.size(width,height);
  clip.volume(0);
  //clip.play();
  clip.loop();
  clip.speed(.3);
  clip.hide();

    zoomBuffer = createGraphics(floor(width * 0.5), floor(height * 0.5));
    clipBuffer = createGraphics(floor(width * 0.3), floor(height * 0.3));

  scenes = [];
  scenes.push({
    name: "scene0",
    draw: drawScene0

  });

  scenes.push({
    name: "scene1",
    draw: drawScene1

  });

  scenes.push({
    name: "scene2",
    draw: drawScene2

  });

  scenes.push({
      name:"scene3",
      draw: drawScene3
  });
    scheduleNextSwitch();
  loop();
  startButton.hide();

  });




}

  function scheduleNextSwitch(){
      nextSwitchTime = millis() + random(3000, 4000);
  }

  function drawVideo(src, xOffset = 0, yOffset = 0, sizeZoom = 1){
      let camW = video.elt.videoWidth;
      let camH = video.elt.videoHeight;

let camAspect = camW / camH;
let canvasAspect = width / height;

let drawW, drawH;

if (camAspect > canvasAspect) {
  // camera is wider than canvas — fit height
  drawH = height;
  drawW = height * camAspect;
} else {
  // camera is taller than canvas — fit width
  drawW = width;
  drawH = width / camAspect;
}

drawW *= sizeZoom;
drawH *= sizeZoom;

let vidX = (width-drawW)/2;
let vidY = (height - drawH) /2;
image(src, vidX + xOffset, vidY, drawW, drawH);
}

  function draw(){

  if(video)
  {
  if(millis()>nextSwitchTime){
      let  newScene = floor(random(scenes.length));
      
      while(newScene===currentScene){
          newScene = floor(random(scenes.length));
      }
      currentScene = newScene;
      
      if(currentScene === 0){
          t = 0;
      }
      scheduleNextSwitch();
  }

  scenes[currentScene].draw();
  }
  }



function drawScene0() {
    //rainbow overlay
background(0);
  
drawVideo(video,0,0,.9);

noTint();
//zoomBuffer.clear();
zoomBuffer.image(video,0,0,zoomBuffer.width,zoomBuffer.height);
zoomBuffer.filter(THRESHOLD, .4);
//zoomBuffer.blendMode(HARD_LIGHT);
tint(255,30);
let zoom = 1.4;
let w = width*zoom;
let h = height*zoom;
t -= 1
let x = t;

drawVideo(zoomBuffer,x + 250,0,1.3);
noTint();

clipBuffer.image(clip,0,0,width,height);
clipBuffer.filter(POSTERIZE, 5);
tint(255,100);
image(clipBuffer,0,0,width,height);
noTint();

}
      let glitchY = null
      let glitchH = null
      let xOffset = null
      let glitchTimer = 0 
function drawScene1() {
    //purple blue
  background(0);
  tint(200,0,255);
    drawVideo(video,0,0,.9);
                filter(POSTERIZE, 15);
loadPixels();               // get pixel data of the current frame
for (let i = 0; i < pixels.length; i += 4) { // loop through every pixel (RGBA)
  if (random() < 0.0001) {   // only affect ~0.1% of pixels per frame
    pixels[i] = 255;        // red
    pixels[i+1] = 255;      // green
    pixels[i+2] = 255;      // blue
  }

}
updatePixels();
  
if(glitchTimer <= 0 && random() < .1){
    glitchY = random(0, height-glitchH);
    glitchH = random(200, 500);
    xOffset = random() < .5 ? -300:500;
    glitchTimer = int(random(1,20));
}
  if(glitchTimer > 0){
        push();
  tint(0,0,255, 255);
  blendMode(ADD);
      image(video, 0, glitchY, width*1.2, glitchH*1.2, xOffset, glitchY, width, glitchH);
      blendMode(BLEND);
      pop();

      glitchTimer--;
  }
  noTint();
//image(video,0,0,width,height);
}

function drawScene2(){
    //high contrast
    background(0);
       
    if(frameCount % 3 === 0){
            flicker = random() <.5 ? 255 : 150;
    }

        zoomBuffer.image(video, 0,0,zoomBuffer.width,zoomBuffer.height);



     tint(255,flicker); 
    drawVideo(zoomBuffer, -300,400,1.4)
    filter(THRESHOLD,.30);
    blendMode(EXCLUSION);

    tint(255);
    drawVideo(zoomBuffer,0,0,.9);
    filter(POSTERIZE, 4)
    blendMode(BLEND);
    noTint();


}

function drawScene3(){
    //red
    background(0);
    translate(width,0);
    scale(-1,1);
    if(frameCount % 7 === 0){
            flicker = random() <.5 ? 255 : 100;
    }

    
    zoomBuffer.image(video,0,0,zoomBuffer.width,zoomBuffer.height);

    clip.speed(1);
    clipBuffer.image(clip,0,0,width*2,height*2);
clipBuffer.filter(THRESHOLD, .65);
tint(100,100,100,flicker);
blendMode(SCREEN);

image(clipBuffer,0,0,width, height);

    tint(255,0,0,255);
    drawVideo(zoomBuffer,0,-300,1);
    filter(POSTERIZE, 10);
blendMode(BLEND);
noTint();
}
// optional: resize the canvas dynamically
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);

  if (video) {
    video.size(windowWidth, windowHeight);
  }

  if (clip) {
    clip.size(windowWidth, windowHeight);
  }

  // Recreate graphics buffers to match new aspect/dimensions
  if (video && video.elt.videoWidth > 0) {
    zoomBuffer = createGraphics(video.elt.videoWidth, video.elt.videoHeight);
  } else {
    zoomBuffer = createGraphics(windowWidth, windowHeight);
  }

  clipBuffer = createGraphics(windowWidth * 0.2, windowHeight * 0.2);
}
</script>

</body>
</html>
